<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序(sort)1.插入排序1.1.直接插入排序​ 直接插入排序是一种最简单的排序方法，整个排序过程为：先将第一个记录视为一个有序的记录序列，然后从第二个记录开始，依次将未排序的记录插入这个有序的记录序列中，直到整个文件中的全部记录排序完毕。在排序过程中，前面的记录序列是已经排好的，而后面的记录序列有待排序处理。 例如： 直接插入排序算法及实现： 123456789101112void directInserionSort(int arr[])&#123; int j,temp; for(int i=1; i&lt;arr.length; i++)&#123; j=i; temp = arr[i]; while(j&gt;0 &amp;&amp; temp &lt;arr[j-1])&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125;&#125; 1.2.折半插入排序​ 将直接插入排序中寻找$A[i]$的插入位置的方法改为采用折半比较，便得到折半插入排序算法。在处理$A[i]$，$A[0]$，$A[1]$，…，$A[i-1]$经按排序码排好序。所谓折半比较，就是在插入$A[i]$时，取$A[\lfloor\frac{i-1}{2}\rfloor]$的排序码与$A[i]$的排序码进行比较，如果A[i]的排序码小于$A[\lfloor\frac{i-1}{2}\rfloor]$的排序码，说明$A[i]$只能插入$A{[0]}$到)$A[\lfloor\frac{i-1}{2}\rfloor]$之间，故可以在$A[{0}]$到$A[\lfloor\frac{i-1}{2}\rfloor-1]$之间继续使用折半比较；否则$A{[i]}$只能插入$A[\lfloor\frac{i-1}{2}\rfloor]$到$A[i-1]$之间，故可以在$A[\lfloor\frac{i-1}{2}\rfloor+1]$到$A[{i-1}]$间继续使用折半比较。如此反复，直到最后能够确定插入的位置为止。一般地，在$A[k]$和$A[r]$之间采用折半，其中间结点为$A[\lfloor\frac{k+r}{2}\rfloor]$，经过一次比较，可以排除一半的记录，把可能插入的区间减少了一半，故称之为折半。执行折半排序的前提是文件记录必须按顺序存储。 例如：在上述例子中的5个记录采用折半插入排序，在前4个记录已经排序的基础上，插入最后一个记录的比较过程如下图所示： 折半插入排序算法及实现： 12345678910111213141516171819202122void binaryInsertionSort(int arr[])&#123; int k,r,temp; for(int i=1; i&lt;arr.length; i++)&#123; /* 采用折半法在已排序的子文件中arr[0]~arr[i-1]之间找arr[i]的插入位置 */ temp = arr[i]; k = 0; r = i-1; while(k &lt;= r)&#123; int m = (k+r)/2; if(temp &lt; arr[m])&#123; r = m-1; &#125;else&#123; k = m+1; &#125; &#125; /* 找到插入位置为k,先将arr[k]~arr[i-1]右移一个位置 */ for(r=i; r&gt;k; r--)&#123; arr[r] = arr[r-1]; &#125; arr[k] = temp ; &#125;&#125; 1.3.希尔排序​ Shell排序法又称为希尔排序法、缩小增量排序法。Shell排序的基本思想是：先选定一个整数$s_1&lt;n$，把待排序文件中的所有记录分成$s_1$个组，所有距离为的$s_1$记录分在同一组内，并对每一组内的记录进行排序。然后，取$s_2&lt;s_1$，重复上述分组和排序的工作，当达到$s_i=1$时，所有记录在同一个组内排好序。 ​ 各组内的排序通常采用直接插入法。由于开始时s的取值较大，每组内记录数较少，所以排序比较快。随着$s_i$的不断缩小，每组内的记录数逐步增多，但由于已经按$s_{i-1}$排好序，因此速度也比较快。 例如：设某文件中待排序记录的排序码分别为28、13、72、85、39、41、6、20。用Shell排序法对该文件进行排序，取$s_1=\frac{n}{2}=4,s_{i+1}=\lfloor{\frac{s_i}{2}}\rfloor$，排序过程如下图所示： Shell排序算法及实现： 12345678910111213141516171819void shellSort(int arr[], int n ,int s)&#123; int i,j,k,temp; /* * 分组排序，初始值增量为s,每循环一次增量减半，知道增量为0时结束 * 此处k&gt;&gt;=1相当于k=k/2,即k的二进制数右移一位 */ for(k=s; k&gt;0; k&gt;&gt;=1)&#123; for(i=k; i&lt;n; i++)&#123; temp = arr[i]; j= i-k; /* 组内排序，将temp直接插入组内合适的记录位置 */ while(j&gt;=0 &amp;&amp; temp&lt;arr[j])&#123; arr[j+k] = arr[j]; j-=k; &#125; arr[j+k] = temp; &#125; &#125;&#125; 2.选择排序2.1.直接选择排序​ 每次从待排序的记录中选出排序码最小的记录，顺序放在已排序的记录序列的最后，直到完成全部排序。 例如：设某文件中待排序的排序码分别为42、32、31、12、25、11、43、10、8。直接选择排序的排序过程如下图： 选择排序算法及实现： 12345678910111213141516directSelectSort(int arr[], int n)&#123; int j,k,temp; for(int i=0; i&lt;n-1; i++)&#123; k=i; for(j=i+1; j&lt;n; j++)&#123; if(arr[j]&lt;arr[k])&#123; k = j; &#125; &#125; if(i!=k)&#123; temp = arr[k]; arr[k] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 2.2.树形选择排序​ 树形选择排序又称为竞赛树排序或胜者树。基本思想：把n个排序码两两进行比较，取出$\lceil\frac{n}{2}\rceil$个较小的排序码作为第1步比较结果保存下来，再把$\lceil\frac{n}{2}\rceil$个排序码两两进行比较，重复上述过程，一直比较出最小的排序码为止。 例如：设某文件中待排序记录的排序码分别为40、35、30、13、24、15、42、14、17。用树形选择排序的排序过程如图所示： 3.交换排序3.1.起泡排序​ 起泡排序的过程如下：首先比较第1个记录和第2个记录的排序码，如果不满足排序要求，则交换第1个记录和第2个记录的位置；然后对第2个记录(可能是新交换过来的最初的第1个记录)和第3个记录进行同样的处理；重复此过程，知道处理完第n-1个记录和第n个记录为止。上述过程称为一次起泡过程，这个过程的处理结果就是将排序码最大(非递减序)或最小(非递增序)的那个记录交换到最后一个记录位置，到达这个记录在最后排序后的正确位置。然后，重复上述起泡过程，但每次只对前面的未排好序的记录进行处理，知道所有的记录均排好序为止。 例如：设某个文件中待排序的排序码为28、6、72、85、39、41、13、20。 起泡排序算法及实现： 123456789101112131415void bubbleSort(int arr[],int n)&#123; int i,temp; boolean flag; for(i=n-1,flag=true; i&gt;0&amp;&amp;flag; i--)&#123; flag = false; for(int j=0; j&lt;i; j++)&#123; if(arr[j+1] &lt; arr[j])&#123; flag = true; temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125;&#125; 3.2.快速排序快速排序算法又称为分区交换排序算法，该排序算法使用分割法对排序文件中的记录进行排序。快速排序算法的处理过程如下：从待排序记录中任选一个记录，以这个记录的排序码作为中心值，将其他所有记录划分成两个部分，第一部分包括所有排序码小于等于中心值的记录，第二部分包括所有排序码大于中心值的记录，而其排序码作为中心值的这个记录，在排序后必然处在这两部分的中间位置；对上述两部分继续采用同样地方式进行排序处理，直到每个部分为空或者只含有一个记录为止。至此，待排序文件中的每个记录都被放置到正确的排序位置。 例如：设某文件中待排序记录的排序码分别为28,13,72,85,39,41,6,20。用快速排序法第一趟排序过程如下： 快速排序算法及实现： 1234567891011121314151617181920212223242526void quickSort(int arr[],int low,int high)&#123; int i,j,temp; if(low&gt;=high)&#123; return ; &#125; i = low; j = high; temp = arr[i]; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; temp&lt;arr[j])&#123; j--; &#125; if(i&lt;j)&#123; arr[i++] = arr[j]; &#125; while(i&lt;j &amp;&amp; arr[j]&lt;=temp)&#123; i++; &#125; if(i&lt;j)&#123; arr[j--] = arr[i]; &#125; &#125; arr[i] = temp; quickSort(arr,low,--j); quickSort(arr,++i,high);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap学习笔记]]></title>
    <url>%2F2019%2F01%2F02%2FBootstrap%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[BootStrap学习笔记]]></content>
  </entry>
  <entry>
    <title><![CDATA[jmeter笔记]]></title>
    <url>%2F2019%2F01%2F01%2Fjmeter%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JmeterJmeter配置jmeter插件下载地址：https://jmeter-plugins.org/install/Install/，下载并放到lib/ext目录下 Jmeter生成测试报告​ 在使用jmeter进行压力测试，有两种方式：GUI、非GUI。不管是GUI，还是非GUI进行测试，对测试结果都可以转化成HTML的测试报告，更直观和方便我们查看和分析。 方式一：GUI 在测试计划里面添加一个Listener(添加任意一个Listener都可以)，在Write result to file/Read from file的FileName的位置填写保存测试结果的路径（路径可以自由指定）（如图所示） 【Jmeter中测试结果的文件格式为：jtl】 通过命令把测试结果转换成HTML 1jmeter -g D:\testcase_by_tools\resultReport\积分商城测试报告.jtl -e -o D:\testcase_by_tools\report 参数说明： -g —指定已存在的测试结果 -o —指定的文件夹必须是不存在的，否则执行失败（如图所示） 注意： 该命令必须在jmeter的bin目录下执行 D:\testcase_by_tools\resultReport\积分商城测试报告.jtl —是积分商城测试报告.jtl所在目录【若积分商城测试报告.jtl保存再bin目录下，路径可以省略，直接写测试结果的名称即可；若result.jtl不是在bin目录下，就要填写完成的路径 D:\testcase_by_tools\report —是转换后HTML报告保存的路径，且生成前无此路径 方式二：非GUI md 先要cd到jmeter的bin目录，然后输入以下命令： 1jmeter -n -t C:\Users\Anthony\Desktop\jmeter\HttpReport.jmx -l C:\Users\Anthony\Desktop\html.csv -e -o C:\Users\Anthony\Desktop\HttpReports 参数说明: n：非GUI模式执行JMeter； t： 脚本文件(.jmx文件)的路径； l： 指定生成测试结果的保存文件(.jtl格式)，此文件必须不存在； e：测试结束后，生成测试报告； o：用于存放测试报告的路径； 处理器正则表达式处理器注：前置处理器和后置处理器都包括正则表达式处理器，用法基本相同 各参数值的含义： 参数 释义 引用名称 在HTTP请求中，引用此数据，需要引用到的名称。（即参数名） 正则表达式 用于将需要的数据提取出来 | 模板 | 表示使用提取到的第几个值：$1$:表示取第1个$2$:表示取第二个以此类推，$n$:表示取第n个 || 匹配数字 | 0代表随机值，1代表全部取值 || 缺省值 | 如果正则表达式没有搜找到值，则使用此缺省值 | BeanShell Processor 定时器Synchronizing Timer 它的其作用是：让各个线程到达集合点后等待，等集齐指定的线程数后，再同时释放以便产生并发。若在指定的超时时间内为等齐，那么不在等待，释放等待中的线程，这种方法可以瞬间产生较大的压力。 Number of Simulated Users to Group by（集合线程数): 要等到多少线程再同时释放。若设置为0，则表示要等待所有线程（Number of Threads（users））到达； Timeout in milliseconds: 超时时间，即最长等待多少毫秒去等待集齐指定的线程。单位毫秒，默认为0；若设置为0，定时器将会无限等待直到线程数达到集合线程数(“Number of Simultaneous Users toGroup”)才释放。若该超时时间是一个大于0的数值，那么系统会等待线程个数达到集合线程数，到达后即可释放。若超时时间已经到达，但指定的集合线程数还没达到，定时器将不再等待，释放已到达的线程。 注： 把SynchronizingTimer放置于请求之前，通常Jmeter按树状结构顺序执行 集合点放到线程组下，将作用于线程组下的所有请求 集合点放到具体请求下，将只作用于该请求 监听器聚合报告解读 Aggregate Report 是 JMeter 常用的一个 Listener，中文被翻译为“聚合报告”。 如果大家都是做Web应用的性能测试，例如只有一个登录的请求，那么在Aggregate Report中，会显示一行数据，共有10个字段，含义分别如下。 Label：每个 JMeter 的 element（例如 HTTP Request）都有一个 Name 属性，这里显示的就是 Name 属性的值 #Samples：表示你这次测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里显示100 Average：平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以Transaction 为单位显示平均响应时间 Median：中位数，也就是 50％ 用户的响应时间小于这个中位数 90% Line：90％ 用户的响应时间 Note：关于 90%、95％和99%并发用户数的含义，请参考下文http://www.cnblogs.com/jackei/archive/2006/11/11/557972.html Min：最小响应时间 Max：最大响应时间 Error%：本次测试中出现错误的请求的数量/请求的总数 Throughput：吞吐量—默认情况下表示每秒完成的请求数（Request per Second），当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数 KB/Sec：每秒从服务器端接收到的数据量，相当于LoadRunner中的Throughput/Sec 图形报告解读 样本数目：总共发送到服务器的请求数 最新样本：代表时间的数字，是服务器响应最后一个请求的时间 平均：总运行时间除以发送到服务器的请求数 偏离：服务器响应时间变化、离散程度测量值的大小，或者，换句话说，就是数据的分布 吞吐量：服务器每分钟处理的请求数。 中值：代表时间的数字，有一半的服务器响应时间低于该值而另一半高于该值 察看结果树Jmeter分布式集群压力测试​ 在使用Jmeter进行性能测试时，如果并发数比较大（比如项目需要支持1000并发），单台电脑的配置（CPU、内存和网络）可能无法支持，这时可以使用Jmeter提供的分布式测试的功能。 一、Jmeter分布式原理： Jmeter分布式测试时，选择其中一台作为调度机（master）,其他机器作为执行机（slave）。 执行时，master会把脚本发送到每台slave上，slave拿到脚本后就开始执行，slave执行时不需要启动GUI，应该是通过命令行模式执行的。 执行完成后，slave会把结果回传到master，master会收集所有slave的信息并汇总。 二、执行机（slave）配置： slave机需要安装Jmeter，Jmeter的版本与master主机版本一致 修改bin目录下的jmeter.propeties文件中的参数（默认使用本机IP和默认端口1099） 12# 将server.rmi.ssl.disable=false修改为trueserver.rmi.ssl.disable=true 如果jmeter脚本中含有csv参数文件，建议放到bin目录下，脚本中csv路径直接写filename.csv（建议window7作为master，其他win7、mac、linux作为slave时，不要写绝对路径） 启动jmeter-server.bat（mac或者linux启动：sh jmeter-server） 多台slave的话，重复1~4步骤就好。 三、调度机（master）配置 修改主机（master）bin目录下的jmeter.propeties文件中的参数 123456# 本机及slave机的IP地址+Jmeter启动的端口号，逗号分隔开,所有的slave均加上# 注意如果slave机中remote_hosts没有启用，则为默认的IP:PORTremote_hosts=172.30.13.161:1099,172.30.37.157:1099# 将server.rmi.ssl.disable=false修改为trueserver.rmi.ssl.disable=true 启动主机（master）bin目录下的jmeter-server.bat 启动主机（master）的jmeter.bat，远程启动所有，或者点击对应ip:port启动某一台 四、自定义端口 上面其实已经实现了Jmeter的分布式测试，这部分主要介绍下如何自定义slave端口： slave：在slave机的Jmeter的bin目录下，找到jmeter.properties文件，修改如下两个配置项： 1234567# RMI port to be used by the server (must start rmiregistry with same port)server_port=2099# 实际操作中我没有修改下面的端口也能正常远程压测，不知道原因？# To change the default port (1099) used to access the server:server.rmi.port=2099 启动slave机上的jmeter-server.bat master：修改jmeter.properties文件 12# 注意修改slave机PORTremote_hosts=172.30.13.161:1099,172.30.37.157:2099 重启master的jmeter.bat，如下图，端口已经变了: 五、其他说明： 调度机（master）和执行机（slave）最好分开，有master需要发送信息给slave并且会接收slave回传回来的测试数据，所以master自身会有消耗，所以建议单独一台机器作为master。 参数文件：如果使用csv文件进行参数化，那么需要把参数文件在每台slave上拷贝一份且路径需要设置成一样。（或者使用文件名， 并把文件直接存放到bin目录下） 每台机器上安装的Jmeter版本和插件最好都一致，否则会出现一些意外。 服务器端监控1.nmon1.1 nmon的安装及使用 检查安装环境 1234567891011# 查看操作系统信息，所检查服务器为64位操作系统uname -a # Linux iZ94pmb2p24Z 2.6.32-431.23.3.el6.x86_64 #1 SMP Thu Jul 31 17:20:51 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux# 查看linux发行商版本，所检查服务器linux版本为：CentOS6.5lsb_release -a LSB Version::base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarchDistributor ID: CentOSDescription: CentOS release 6.5 (Final)Release: 6.5Codename: Final 下载安装文件： nmon: 版本：nmon_linux_14i.tar.gz （下载适合服务器的版本） 地址：https://osdn.jp/projects/sfnet_nmon/releases/ nmonanalyser: 版本：nmon_analyser_v47.zip 地址： https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/Power+Systems/page/nmon_analyser 安装 安装位置：/home/nmon （任意目录） 1234567891011# 1.在home目录下创建nmon目录（当前已在home目录下）mkdir nmon# 2.上传nmon_linux_14i.tar.gz到nmon目录下# 3.解压tar -zxvf nmon_linux_14i.tar.gz# 4.回到home目录，给nmon文件夹赋予权限cd ..chmod -R 755 nmon# 5.回到nmon目录，启动nmoncd mmon./nmon_x86_64_sles11 安装成功显示一下界面： 实时监控 输入一下命令： | 命令 | 解释 || —— | ————————— || c | 显示CPU相关信息 || m | 对应内存 || n | 对应网络 || d | 查看磁盘信息 || t | 查看系统的进程信息 | 配置环境变量 123456789101112131415161718192021# 1.修改启动文件名称mv nmon_x86_64_sles11 nmon./nmon# 2.添加到环境变量中vim /etc/profie# 在profile加入一下两行PATH=$PATH:/home/nmon/export PATH# 3.保存并退出按ESC键:w # 保存文件但不退出vi编辑:w! # 强制保存，不退出vi编辑:w file # 将修改另存到file中，不退出vi编辑:wq # 保存文件并退出vi 编辑:wq! # 强制保存文件并退出vi 编辑:q # 不保存文件并退出vi 编辑:q! # 不保存文件并强制退出vi 编辑:e! # 放弃所有修改，从上次保存文件开始在编辑# 4.使配置文件立即生效（如没有生效则重新断开服务器重新连接再试）source /etc/profilenmon # 可以在任何目录下执行nmon命令来启动nmon 采集监控数据 在实际的性能测试中我们需要把一段时间之内的数据记录下来，如下： 12345678# 采集数据nmon -s 10 -c 60 -f -m /home/nmon参数说明：-s 10 每隔10秒抽样一次-c 60 取出多个抽样数量，这里是抽取60次，即监控10*60/60=10分钟-f 按标准格式输出文件名称：&lt;hostname&gt;_YYMMDD_HHMM.nmon-m 指定监控文件的存放目录，-m后跟指定目录 生成图形化报表 将.nmon文件转化为.csv文件 sort hostname_190514_1941.nmon &gt; hostname_190514_1941.csv 或者下载本地修改后缀名即可 将.csv文件下载到本地 打开nmon analyser工具 在本地解压nmon_analyser_v47.zip 双击打开：nmon analyser v47.xlsm 点击Analyse nmon data按钮，加载之前下载的hostname_190514_1941.nmon（后者转换后的csv文件） 注意：本地安装最好excel，不要使用wps 结果分析系 结果nmon运行 nmon运行本身是会消耗系统资源，如需关闭nmon，直接kill掉 123# 查看nmon进程的pidps -ef | grep nmonkill -9 pid 1.2 nmon结果分析使用nmon analyser生成的结果文件包含了N多个sheet页，下面只是结合个人经验对几个主要的页面图标进行一些分析介绍：（完全自己查看分析翻译，不正确的请指出） 1.2.1 整体信息页面SYS_SUMM 1.折线图中蓝线为cpu占有率变化情况；粉线为磁盘IO的变化情况； 2.下面表各种左边的位磁盘的总体数据，包括如下几个： Avg tps during an interval:每个间隔时间内，平均每秒IO数，也可以理解为提交处理的次数 Max tps during an interval:每个间隔时间内，每秒最大IO次数； Max tps interval time:最大传送次数出现的时间点； Total number of Mbytes read:整个监控时间内读的字节数； Total number of Mbytes written:整个监控时间内写的字节数； Read/Write Ratio:读写比率； 3.右边的为CPU的总体数据，可以获取如下信息； cpu被User/Sys/Wait所占百分比； cpu整体平均空闲率/占有率，以及最大的空闲率/占有率； cpu各项数据最大值和平均值的比率； 1.2.2 cpu各项详细的数据1.CPU_ALL页面：该页面可以看到如下图的CPU整体上在每个监控点的数据，包括User%、Sys%、Wait%、Idle%、CPU%以及CPUs（cpu个数）及对应图表；]]></content>
      <tags>
        <tag>jmeter</tag>
      </tags>
  </entry>
</search>
