<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序(sort)1.插入排序1.1.直接插入排序​ 直接插入排序是一种最简单的排序方法，整个排序过程为：先将第一个记录视为一个有序的记录序列，然后从第二个记录开始，依次将未排序的记录插入这个有序的记录序列中，直到整个文件中的全部记录排序完毕。在排序过程中，前面的记录序列是已经排好的，而后面的记录序列有待排序处理。 例如： 直接插入排序算法及实现： 123456789101112void directInserionSort(int arr[])&#123; int j,temp; for(int i=1; i&lt;arr.length; i++)&#123; j=i; temp = arr[i]; while(j&gt;0 &amp;&amp; temp &lt;arr[j-1])&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125;&#125; 1.2.折半插入排序​ 将直接插入排序中寻找$A[i]$的插入位置的方法改为采用折半比较，便得到折半插入排序算法。在处理$A[i]$，$A[0]$，$A[1]$，…，$A[i-1]$经按排序码排好序。所谓折半比较，就是在插入$A[i]$时，取$A[\lfloor\frac{i-1}{2}\rfloor]$的排序码与$A[i]$的排序码进行比较，如果A[i]的排序码小于$A[\lfloor\frac{i-1}{2}\rfloor]$的排序码，说明$A[i]$只能插入$A{[0]}$到)$A[\lfloor\frac{i-1}{2}\rfloor]$之间，故可以在$A[{0}]$到$A[\lfloor\frac{i-1}{2}\rfloor-1]$之间继续使用折半比较；否则$A{[i]}$只能插入$A[\lfloor\frac{i-1}{2}\rfloor]$到$A[i-1]$之间，故可以在$A[\lfloor\frac{i-1}{2}\rfloor+1]$到$A[{i-1}]$间继续使用折半比较。如此反复，直到最后能够确定插入的位置为止。一般地，在$A[k]$和$A[r]$之间采用折半，其中间结点为$A[\lfloor\frac{k+r}{2}\rfloor]$，经过一次比较，可以排除一半的记录，把可能插入的区间减少了一半，故称之为折半。执行折半排序的前提是文件记录必须按顺序存储。 例如：在上述例子中的5个记录采用折半插入排序，在前4个记录已经排序的基础上，插入最后一个记录的比较过程如下图所示： 折半插入排序算法及实现： 12345678910111213141516171819202122void binaryInsertionSort(int arr[])&#123; int k,r,temp; for(int i=1; i&lt;arr.length; i++)&#123; /* 采用折半法在已排序的子文件中arr[0]~arr[i-1]之间找arr[i]的插入位置 */ temp = arr[i]; k = 0; r = i-1; while(k &lt;= r)&#123; int m = (k+r)/2; if(temp &lt; arr[m])&#123; r = m-1; &#125;else&#123; k = m+1; &#125; &#125; /* 找到插入位置为k,先将arr[k]~arr[i-1]右移一个位置 */ for(r=i; r&gt;k; r--)&#123; arr[r] = arr[r-1]; &#125; arr[k] = temp ; &#125;&#125; 1.3.希尔排序​ Shell排序法又称为希尔排序法、缩小增量排序法。Shell排序的基本思想是：先选定一个整数$s_1&lt;n$，把待排序文件中的所有记录分成$s_1$个组，所有距离为的$s_1$记录分在同一组内，并对每一组内的记录进行排序。然后，取$s_2&lt;s_1$，重复上述分组和排序的工作，当达到$s_i=1$时，所有记录在同一个组内排好序。 ​ 各组内的排序通常采用直接插入法。由于开始时s的取值较大，每组内记录数较少，所以排序比较快。随着$s_i$的不断缩小，每组内的记录数逐步增多，但由于已经按$s_{i-1}$排好序，因此速度也比较快。 例如：设某文件中待排序记录的排序码分别为28、13、72、85、39、41、6、20。用Shell排序法对该文件进行排序，取$s_1=\frac{n}{2}=4,s_{i+1}=\lfloor{\frac{s_i}{2}}\rfloor$，排序过程如下图所示： Shell排序算法及实现： 12345678910111213141516171819void shellSort(int arr[], int n ,int s)&#123; int i,j,k,temp; /* * 分组排序，初始值增量为s,每循环一次增量减半，知道增量为0时结束 * 此处k&gt;&gt;=1相当于k=k/2,即k的二进制数右移一位 */ for(k=s; k&gt;0; k&gt;&gt;=1)&#123; for(i=k; i&lt;n; i++)&#123; temp = arr[i]; j= i-k; /* 组内排序，将temp直接插入组内合适的记录位置 */ while(j&gt;=0 &amp;&amp; temp&lt;arr[j])&#123; arr[j+k] = arr[j]; j-=k; &#125; arr[j+k] = temp; &#125; &#125;&#125; 2.选择排序2.1.直接选择排序​ 每次从待排序的记录中选出排序码最小的记录，顺序放在已排序的记录序列的最后，直到完成全部排序。 例如：设某文件中待排序的排序码分别为42、32、31、12、25、11、43、10、8。直接选择排序的排序过程如下图： 选择排序算法及实现： 12345678910111213141516directSelectSort(int arr[], int n)&#123; int j,k,temp; for(int i=0; i&lt;n-1; i++)&#123; k=i; for(j=i+1; j&lt;n; j++)&#123; if(arr[j]&lt;arr[k])&#123; k = j; &#125; &#125; if(i!=k)&#123; temp = arr[k]; arr[k] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 2.2.树形选择排序​ 树形选择排序又称为竞赛树排序或胜者树。基本思想：把n个排序码两两进行比较，取出$\lceil\frac{n}{2}\rceil$个较小的排序码作为第1步比较结果保存下来，再把$\lceil\frac{n}{2}\rceil$个排序码两两进行比较，重复上述过程，一直比较出最小的排序码为止。 例如：设某文件中待排序记录的排序码分别为40、35、30、13、24、15、42、14、17。用树形选择排序的排序过程如图所示： 3.交换排序3.1.起泡排序​ 起泡排序的过程如下：首先比较第1个记录和第2个记录的排序码，如果不满足排序要求，则交换第1个记录和第2个记录的位置；然后对第2个记录(可能是新交换过来的最初的第1个记录)和第3个记录进行同样的处理；重复此过程，知道处理完第n-1个记录和第n个记录为止。上述过程称为一次起泡过程，这个过程的处理结果就是将排序码最大(非递减序)或最小(非递增序)的那个记录交换到最后一个记录位置，到达这个记录在最后排序后的正确位置。然后，重复上述起泡过程，但每次只对前面的未排好序的记录进行处理，知道所有的记录均排好序为止。 例如：设某个文件中待排序的排序码为28、6、72、85、39、41、13、20。 起泡排序算法及实现： 123456789101112131415void bubbleSort(int arr[],int n)&#123; int i,temp; boolean flag; for(i=n-1,flag=true; i&gt;0&amp;&amp;flag; i--)&#123; flag = false; for(int j=0; j&lt;i; j++)&#123; if(arr[j+1] &lt; arr[j])&#123; flag = true; temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125;&#125; 3.2.快速排序快速排序算法又称为分区交换排序算法，该排序算法使用分割法对排序文件中的记录进行排序。快速排序算法的处理过程如下：从待排序记录中任选一个记录，以这个记录的排序码作为中心值，将其他所有记录划分成两个部分，第一部分包括所有排序码小于等于中心值的记录，第二部分包括所有排序码大于中心值的记录，而其排序码作为中心值的这个记录，在排序后必然处在这两部分的中间位置；对上述两部分继续采用同样地方式进行排序处理，直到每个部分为空或者只含有一个记录为止。至此，待排序文件中的每个记录都被放置到正确的排序位置。 例如：设某文件中待排序记录的排序码分别为28,13,72,85,39,41,6,20。用快速排序法第一趟排序过程如下： 快速排序算法及实现： 1234567891011121314151617181920212223242526void quickSort(int arr[],int low,int high)&#123; int i,j,temp; if(low&gt;=high)&#123; return ; &#125; i = low; j = high; temp = arr[i]; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; temp&lt;arr[j])&#123; j--; &#125; if(i&lt;j)&#123; arr[i++] = arr[j]; &#125; while(i&lt;j &amp;&amp; arr[j]&lt;=temp)&#123; i++; &#125; if(i&lt;j)&#123; arr[j--] = arr[i]; &#125; &#125; arr[i] = temp; quickSort(arr,low,--j); quickSort(arr,++i,high);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap学习笔记]]></title>
    <url>%2F2019%2F01%2F02%2FBootstrap%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[BootStrap学习笔记]]></content>
  </entry>
  <entry>
    <title><![CDATA[jmeter笔记]]></title>
    <url>%2F2019%2F01%2F01%2Fjmeter%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Jmeter配置jmeter插件下载地址：https://jmeter-plugins.org/install/Install/，下载并放到lib/ext目录下 Jmeter生成测试报告​ 在使用jmeter进行压力测试，有两种方式：GUI、非GUI。不管是GUI，还是非GUI进行测试，对测试结果都可以转化成HTML的测试报告，更直观和方便我们查看和分析。 方式一：GUI 在测试计划里面添加一个Listener(添加任意一个Listener都可以)，在Write result to file/Read from file的FileName的位置填写保存测试结果的路径（路径可以自由指定）（如图所示） 【Jmeter中测试结果的文件格式为：jtl】 通过命令把测试结果转换成HTML 1jmeter -g D:\testcase_by_tools\resultReport\积分商城测试报告.jtl -e -o D:\testcase_by_tools\report 参数说明： -g —指定已存在的测试结果 -o —指定的文件夹必须是不存在的，否则执行失败（如图所示） 注意： 该命令必须在jmeter的bin目录下执行 D:\testcase_by_tools\resultReport\积分商城测试报告.jtl —是积分商城测试报告.jtl所在目录【若积分商城测试报告.jtl保存再bin目录下，路径可以省略，直接写测试结果的名称即可；若result.jtl不是在bin目录下，就要填写完成的路径 D:\testcase_by_tools\report —是转换后HTML报告保存的路径，且生成前无此路径 方式二：非GUI md 先要cd到jmeter的bin目录，然后输入以下命令： jmeter -n -t C:\Users\Anthony\Desktop\jmeter\HttpReport.jmx -l C:\Users\Anthony\Desktop\html.csv -e -o C:\Users\Anthony\Desktop\HttpReports 参数说明: n：非GUI模式执行JMeter； t： 脚本文件(.jmx文件)的路径； l： 指定生成测试结果的保存文件(.jtl格式)，此文件必须不存在； e：测试结束后，生成测试报告； o：用于存放测试报告的路径； 处理器正则表达式处理器注：前置处理器和后置处理器都包括正则表达式处理器，用法基本相同 各参数值的含义： 参数 释义 引用名称 在HTTP请求中，引用此数据，需要引用到的名称。（即参数名） 正则表达式 用于将需要的数据提取出来 模板 表示使用提取到的第几个值：$1$:表示取第1个$2$:表示取第二个以此类推$n$:表示取第n个 匹配数字 0代表随机值，1代表全部取值 缺省值 如果正则表达式没有搜找到值，则使用此缺省值 BeanShell Processor 定时器Synchronizing Timer 它的其作用是：让各个线程到达集合点后等待，等集齐指定的线程数后，再同时释放以便产生并发。若在指定的超时时间内为等齐，那么不在等待，释放等待中的线程，这种方法可以瞬间产生较大的压力。 Number of Simulated Users to Group by（集合线程数): 要等到多少线程再同时释放。若设置为0，则表示要等待所有线程（Number of Threads（users））到达； Timeout in milliseconds: 超时时间，即最长等待多少毫秒去等待集齐指定的线程。单位毫秒，默认为0；若设置为0，定时器将会无限等待直到线程数达到集合线程数(“Number of Simultaneous Users toGroup”)才释放。若该超时时间是一个大于0的数值，那么系统会等待线程个数达到集合线程数，到达后即可释放。若超时时间已经到达，但指定的集合线程数还没达到，定时器将不再等待，释放已到达的线程。 注： 把SynchronizingTimer放置于请求之前，通常Jmeter按树状结构顺序执行 集合点放到线程组下，将作用于线程组下的所有请求 集合点放到具体请求下，将只作用于该请求 监听器聚合报告解读 Aggregate Report 是 JMeter 常用的一个 Listener，中文被翻译为“聚合报告”。 如果大家都是做Web应用的性能测试，例如只有一个登录的请求，那么在Aggregate Report中，会显示一行数据，共有10个字段，含义分别如下。 Label：每个 JMeter 的 element（例如 HTTP Request）都有一个 Name 属性，这里显示的就是 Name 属性的值 #Samples：表示你这次测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里显示100 Average：平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以Transaction 为单位显示平均响应时间 Median：中位数，也就是 50％ 用户的响应时间小于这个中位数 90% Line：90％ 用户的响应时间 Note：关于 90%、95％和99%并发用户数的含义，请参考下文http://www.cnblogs.com/jackei/archive/2006/11/11/557972.html Min：最小响应时间 Max：最大响应时间 Error%：本次测试中出现错误的请求的数量/请求的总数 Throughput：吞吐量—默认情况下表示每秒完成的请求数（Request per Second），当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数 KB/Sec：每秒从服务器端接收到的数据量，相当于LoadRunner中的Throughput/Sec 图形报告解读 样本数目：总共发送到服务器的请求数 最新样本：代表时间的数字，是服务器响应最后一个请求的时间 平均：总运行时间除以发送到服务器的请求数 偏离：服务器响应时间变化、离散程度测量值的大小，或者，换句话说，就是数据的分布 吞吐量：服务器每分钟处理的请求数。 中值：代表时间的数字，有一半的服务器响应时间低于该值而另一半高于该值 察看结果树]]></content>
      <categories>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
      </tags>
  </entry>
</search>
